# Documentación Técnica del Simulador de Producción Textil

## 1. Introducción

Este proyecto implementa un simulador de eventos discretos para analizar el comportamiento de una línea de producción textil con cuatro estaciones de trabajo en serie, específicamente máquinas de coser que procesan prendas de vestir. El simulador permite visualizar en tiempo real el flujo de prendas a través del sistema mediante una representación tridimensional interactiva, calcular métricas de rendimiento dinámicamente y analizar el impacto de diferentes parámetros operacionales sobre el desempeño del sistema. Esta herramienta combina técnicas avanzadas de simulación computacional con tecnologías modernas de visualización web para crear una experiencia educativa e interactiva que facilita la comprensión de sistemas de producción complejos.

El objetivo principal del simulador es proporcionar una plataforma visual e interactiva que permita analizar el comportamiento de una línea de producción textil bajo diferentes condiciones operacionales. El sistema visualiza el comportamiento de la línea de producción en un entorno tridimensional donde es posible observar en tiempo real cómo las prendas fluyen a través de las diferentes estaciones de trabajo, cómo se forman y vacían las colas de espera, y cómo se comportan los servidores bajo diferentes cargas de trabajo. Adicionalmente, el simulador calcula métricas de rendimiento en tiempo real, incluyendo tiempos promedio de espera en cola, tiempos promedio de servicio en cada estación, y tiempos totales en el sistema. Estas métricas permiten analizar el impacto de cambios en parámetros operacionales como las tasas de llegada de lotes, las velocidades de procesamiento de cada servidor, y los factores de aceleración temporal, proporcionando así una herramienta valiosa tanto para fines educativos como para el análisis práctico de sistemas de producción.

El modelo de producción simulado consiste en una línea de producción con cuatro estaciones de trabajo dispuestas en serie, cada una representando una etapa específica del proceso de manufactura textil. La primera estación, denominada S1, corresponde a la máquina de Cama Plana, seguida por S2 que representa la Fileteadora, luego S3 que es el Collarete, y finalmente S4 que corresponde a la Plancha. Los lotes de prendas llegan al sistema con tamaños fijos que siguen una secuencia cíclica de 200, 150 y 50 prendas, repitiéndose este patrón indefinidamente. Esta secuencia tiene un promedio de 133.33 prendas por lote, lo cual refleja la variabilidad real observada en los procesos de producción. Las llegadas de lotes siguen una distribución exponencial con una tasa de llegada configurable, y el primer lote llega inmediatamente al inicio de la simulación para facilitar la observación del comportamiento del sistema desde el primer momento. El sistema opera bajo un horario laboral definido que comprende días laborales de Lunes a Sábado, con dos turnos diarios: un turno matutino de 08:00 a 12:00 horas y un turno vespertino de 14:00 a 18:00 horas. Dentro de cada turno se incluyen descansos de 10 minutos cada 2 horas, específicamente a las 10:00 y 16:00 horas, lo cual refleja las condiciones reales de operación de una planta de producción textil.

## 2. Arquitectura del Sistema

El simulador sigue una arquitectura de componentes React con una clara separación de responsabilidades organizada en tres capas principales que facilitan el mantenimiento, la extensibilidad y la comprensión del sistema. La capa de presentación está constituida por los componentes React que gestionan la interfaz de usuario y la visualización tridimensional. El componente principal App.tsx actúa como orquestador de la aplicación, gestionando el ciclo de vida completo de la simulación mediante el uso de requestAnimationFrame, controlando la transición entre la pantalla de configuración inicial y la simulación activa, e integrando controles de ajuste de parámetros en tiempo real. El componente Scene.tsx constituye la escena tridimensional principal donde se renderizan todos los elementos visuales, incluyendo las máquinas de coser, los trabajadores, las barras de cola que representan visualmente la cantidad de prendas esperando en cada estación, y los paneles de información que muestran métricas y datos del sistema. La carpeta components contiene todos los componentes especializados, incluyendo ConfigScreen para la configuración inicial, Operator para los modelos tridimensionales de trabajadores, SewingMachine para las máquinas, QueueBar para la visualización de colas, y diversos paneles informativos como MetricsPanel y NextArrivalPanel.

La capa de estado está implementada mediante Zustand, una librería de gestión de estado global que actúa como intermediario entre la lógica de simulación y la presentación. El store de Zustand, definido en store.ts, mantiene el estado global de la simulación incluyendo los parámetros actuales, la instancia del motor de simulación, y el snapshot actual del sistema que contiene todas las métricas y estados relevantes. Este store expone funciones para actualizar parámetros, avanzar la simulación mediante la función tick que recibe el tiempo transcurrido en segundos reales, y resetear el sistema completamente. La arquitectura de Zustand permite que los componentes React se suscriban selectivamente a las partes del estado que necesitan, minimizando re-renderizados innecesarios y mejorando el rendimiento del sistema.

La capa de lógica de negocio está completamente separada de la presentación y contiene toda la implementación del motor de simulación de eventos discretos. El archivo engine.ts contiene la clase Engine que implementa el algoritmo principal de simulación, gestionando el calendario de eventos, procesando llegadas y salidas en orden cronológico, y calculando todas las métricas acumulativas del sistema. El archivo servers.ts define las clases FIFOQueue y Server que representan las colas de espera y las estaciones de trabajo respectivamente, implementando la lógica de encolado, inicio de servicio, y finalización de servicio. El archivo rng.ts contiene el generador de números aleatorios basado en el algoritmo XORShift32, que proporciona números pseudoaleatorios reproducibles necesarios para generar los tiempos de llegada y servicio según las distribuciones probabilísticas definidas. El archivo schedule.ts implementa toda la lógica relacionada con los horarios laborales, incluyendo funciones para determinar si el sistema está en horario de trabajo, formatear fechas y horas, y determinar el estado laboral actual que se muestra en la interfaz. Finalmente, types.ts contiene todas las definiciones de interfaces y tipos TypeScript que proporcionan la estructura de datos para parámetros, trabajos, lotes, eventos, y snapshots del sistema.

El flujo de datos en el sistema sigue un patrón unidireccional donde la información fluye desde la configuración del usuario hasta la visualización final. Cuando el usuario configura los parámetros en la pantalla de configuración, estos se aplican al store de Zustand mediante la función setParams, la cual actualiza tanto el estado de Zustand como los parámetros internos del motor de simulación. Durante la ejecución, el componente App.tsx ejecuta un loop continuo usando requestAnimationFrame que calcula el tiempo transcurrido desde el último frame y llama a la función tick del store, pasándole este delta de tiempo. La función tick multiplica este tiempo por el factor de velocidad configurado y llama al método step del motor de simulación, el cual avanza el tiempo simulado y procesa todos los eventos que ocurren durante ese intervalo. Después de procesar los eventos, el motor genera un nuevo snapshot del sistema mediante el método snapshot, que calcula todas las métricas actuales y estados. Este snapshot se actualiza en el store de Zustand, lo que automáticamente dispara el re-renderizado de todos los componentes React que están suscritos a ese estado, incluyendo Scene.tsx y todos sus componentes hijos, resultando en una actualización visual en tiempo real de toda la escena tridimensional.

## 3. Tecnologías Utilizadas

El proyecto está construido utilizando TypeScript versión 5.9.3 como lenguaje principal, lo cual proporciona tipado estático que previene una gran cantidad de errores en tiempo de desarrollo antes de que el código sea ejecutado. TypeScript facilita enormemente el mantenimiento del código al permitir definir interfaces claras que documentan la estructura esperada de los datos, mejora la experiencia de desarrollo mediante autocompletado inteligente y detección temprana de errores, y es esencial para proyectos React modernos con arquitecturas complejas donde la claridad de tipos es fundamental para la comprensión y extensión del sistema.

El framework base utilizado es React versión 19.1.1, que proporciona la capacidad de construir interfaces de usuario mediante componentes reutilizables que encapsulan tanto la estructura visual como la lógica de presentación. React permite construir la interfaz mediante componentes modulares donde cada componente tiene responsabilidades bien definidas, utiliza un sistema de hooks que facilita el manejo de estado local mediante useState, efectos secundarios mediante useEffect, y referencias persistentes mediante useRef, y proporciona reactividad automática donde la interfaz de usuario se actualiza automáticamente cuando cambia el estado subyacente. React DOM versión 19.1.1 es el renderizador que toma los componentes React y los convierte en elementos del Document Object Model del navegador, siendo necesario para cualquier aplicación React que se ejecute en un entorno web.

Para la visualización tridimensional, el proyecto utiliza Three.js versión 0.181.0, que es la librería estándar de la industria para gráficos tridimensionales en aplicaciones web. Three.js proporciona control completo sobre el renderizado tridimensional, incluyendo soporte para modelos en formato GLTF y GLB, sistemas de iluminación complejos, cámaras configurables, y geometrías personalizadas. Esta librería actúa como la base de bajo nivel sobre la cual se construye toda la visualización tridimensional del simulador.

React Three Fiber versión 9.4.0 es una librería que permite utilizar Three.js de manera declarativa mediante componentes React, transformando así el paradigma imperativo tradicional de Three.js en un enfoque declarativo que se integra naturalmente con el ecosistema React. Esta integración permite utilizar hooks de React para gestionar el estado de los objetos tridimensionales, pasar props entre componentes para configurar la escena, y simplificar enormemente el manejo del ciclo de vida de los objetos 3D. React Three Fiber gestiona automáticamente la creación, actualización y destrucción de recursos como geometrías, materiales y texturas, lo cual reduce significativamente la complejidad del código y previene errores comunes relacionados con la gestión manual de memoria en aplicaciones 3D.

React Three Drei versión 10.7.6 es una colección de helpers y abstracciones que simplifican tareas comunes en React Three Fiber. En este proyecto se utiliza específicamente el hook useGLTF para cargar modelos tridimensionales en formato GLTF y GLB de manera eficiente, el componente Html que permite renderizar contenido HTML dentro de la escena tridimensional para crear paneles de información flotantes, y OrbitControls que proporciona controles de cámara interactivos que permiten al usuario rotar, hacer zoom y desplazar la vista de la escena. Esta librería abstrae complejidades comunes de Three.js como la carga y optimización de modelos, reduce la cantidad de código repetitivo necesario, y facilita tareas complejas como el renderizado de interfaces de usuario HTML directamente dentro del espacio tridimensional.

La gestión de estado global está implementada mediante Zustand versión 5.0.8, una librería extremadamente ligera que pesa aproximadamente un kilobyte de código sin dependencias pesadas. Zustand proporciona una API minimalista que es mucho más simple de usar que alternativas como Redux, realiza actualizaciones eficientes que evitan re-renderizados innecesarios de componentes, tiene excelente soporte para TypeScript permitiendo tipado completo del estado, y es particularmente adecuado para simulaciones donde el estado se actualiza frecuentemente y se necesita un rendimiento óptimo. En este proyecto, el store de Zustand mantiene los parámetros de la simulación, la instancia del motor de simulación, y el snapshot actual que contiene todas las métricas y estados del sistema, proporcionando así una fuente única de verdad que es accesible desde cualquier componente de la aplicación.

Vite versión 7.1.7 es utilizado como herramienta de construcción y servidor de desarrollo, proporcionando Hot Module Replacement extremadamente rápido que permite ver los cambios en el código casi instantáneamente durante el desarrollo. Vite crea bundles eficientes utilizando módulos ES nativos del navegador, funciona con configuración mínima para proyectos React y TypeScript, y proporciona soporte completo para TypeScript, JSX y CSS sin necesidad de configuración adicional, lo cual acelera significativamente el ciclo de desarrollo.

ESLint versión 9.36.0 es utilizado como linter para mantener la calidad y consistencia del código, detectando errores potenciales antes de que el código sea ejecutado, aplicando estándares de codificación consistentes, e integrando con TypeScript para realizar análisis type-aware que puede detectar problemas relacionados con tipos que no serían evidentes en un análisis estático tradicional.

Leva versión 0.10.1 proporciona un panel de controles flotante que permite ajustar parámetros de la simulación en tiempo real sin necesidad de recargar la aplicación. Esta librería genera automáticamente una interfaz de usuario a partir de una configuración simple, es extremadamente útil para debugging y experimentación durante el desarrollo, y puede ser ocultada o mostrada según la necesidad del usuario. Framer Motion versión 12.23.24 está incluido en el proyecto como librería para animaciones y transiciones, aunque actualmente no se utiliza activamente pero está disponible para futuras implementaciones de animaciones fluidas en la interfaz.

Los modelos tridimensionales utilizados en el proyecto están en formato GLTF y GLB, que son los formatos estándar de la industria para modelos 3D en aplicaciones web. El formato GLB es una versión binaria comprimida de GLTF que reduce significativamente el tamaño de los archivos, es completamente compatible con Three.js y React Three Fiber, y soporta animaciones, materiales complejos y texturas de alta calidad. Este formato permite cargar modelos detallados de máquinas de coser y trabajadores de manera eficiente, manteniendo un balance óptimo entre calidad visual y rendimiento.

## 4. Estructura del Código y Componentes Principales

El proyecto está organizado en una estructura de directorios clara que separa las responsabilidades y facilita la navegación y comprensión del código. La carpeta public contiene la subcarpeta models donde se almacenan todos los archivos GLB de los modelos tridimensionales, incluyendo las máquinas de coser y los diferentes modelos de trabajadores. La carpeta src contiene todo el código fuente, con components albergando todos los componentes React reutilizables, sim conteniendo toda la lógica de simulación separada de la presentación, y state conteniendo la gestión de estado global mediante Zustand.

El componente App.tsx actúa como el orquestador principal de la aplicación, gestionando el ciclo de vida completo de la simulación mediante un loop basado en requestAnimationFrame que se ejecuta aproximadamente 60 veces por segundo cuando la simulación está activa. Este componente controla la transición entre la pantalla de configuración inicial y la simulación activa mediante un estado local isSimulating, e integra los controles de Leva que permiten ajustar parámetros en tiempo real durante la ejecución. El flujo de ejecución comienza cuando App.tsx renderiza ConfigScreen si isSimulating es false, luego cuando el usuario presiona el botón "Iniciar", se cambia isSimulating a true y se inicia el loop de simulación que en cada frame calcula el tiempo transcurrido desde el último frame y llama a la función tick del store, la cual avanza el motor de simulación.

El componente Scene.tsx es responsable de renderizar toda la escena tridimensional principal, configurando la iluminación mediante luces ambientales y direccionales que crean sombras realistas, estableciendo la posición y configuración de la cámara, y posicionando todos los elementos tridimensionales según una disposición 2x2 donde cada máquina y su trabajador correspondiente están ubicados en las esquinas de un cuadrado. Este componente renderiza cuatro máquinas de coser mediante el componente SewingMachine, cuatro trabajadores mediante el componente Operator, cuatro barras de cola mediante QueueBar que crecen visualmente según la cantidad de prendas esperando, un componente Room que representa el ambiente o cuarto donde se desarrolla la producción, y varios paneles HTML flotantes que muestran información mediante el componente Html de React Three Drei, incluyendo el panel de métricas detalladas, el panel de próxima llegada, y un resumen compacto en la esquina inferior derecha.

La clase Engine definida en sim/engine.ts implementa el motor principal de simulación de eventos discretos, que es el núcleo computacional de todo el sistema. Esta clase mantiene un calendario de eventos ordenado cronológicamente que contiene todos los eventos futuros programados, incluyendo llegadas de lotes y finalizaciones de servicio en cada servidor. El método step recibe un delta de tiempo simulado y avanza el tiempo del sistema, procesando todos los eventos que ocurren durante ese intervalo en orden cronológico. Para cada evento de tipo ARRIVAL, el motor crea trabajos individuales para cada prenda del lote y los encola en el primer servidor, mientras que para cada evento de tipo DEPARTURE, el motor finaliza el servicio en el servidor actual, calcula y acumula las métricas correspondientes, y mueve el trabajo al siguiente servidor en la cadena o lo elimina del sistema si es el último servidor. La clase también mantiene cuatro instancias de FIFOQueue que representan las colas de espera de cada servidor, y cuatro instancias de Server que representan las estaciones de trabajo, cada una con su propia tasa de servicio configurable.

El componente Operator.tsx es responsable del renderizado de los modelos tridimensionales de trabajadores, implementando técnicas avanzadas para asegurar que múltiples instancias del mismo modelo puedan renderizarse correctamente sin interferencias. Este componente carga modelos GLB utilizando el hook useGLTF de React Three Drei, y luego realiza una clonación profunda de cada instancia para evitar que Three.js comparta referencias entre instancias, lo cual podría causar que cambios en una instancia afecten a todas las demás. La clonación profunda incluye clonar todas las geometrías, materiales, y asignar UUIDs únicos a todos los elementos del modelo clonado, asegurando así que cada trabajador sea una entidad completamente independiente. El componente utiliza useRef para almacenar el modelo clonado fuera del ciclo de renderizado de React, lo cual previene que React Three Fiber optimice o una las instancias, y ajusta la posición, rotación y escala de cada trabajador según su ubicación en la escena. Adicionalmente, el componente solo se renderiza durante el horario laboral, desapareciendo automáticamente cuando el sistema está fuera de horario o en descanso.

## 5. Modelo de Simulación Matemático

El simulador implementa una simulación de eventos discretos, que es un tipo de simulación computacional donde el tiempo avanza en saltos discretos cada vez que ocurre un evento significativo en el sistema. En este tipo de simulación, el tiempo no avanza de manera continua sino que salta directamente al momento en que ocurre el siguiente evento programado, lo cual es computacionalmente eficiente porque no es necesario evaluar el estado del sistema en cada instante de tiempo, sino solo en los momentos específicos donde ocurren cambios. Los eventos que pueden ocurrir en este sistema son de dos tipos: eventos ARRIVAL que representan la llegada de un nuevo lote de prendas al sistema, y eventos DEPARTURE que representan la finalización del procesamiento de una prenda en una estación de trabajo específica. Entre eventos, el estado del sistema permanece constante, lo cual es una característica fundamental de las simulaciones de eventos discretos que permite optimizar significativamente el rendimiento computacional.

Las llegadas de lotes al sistema siguen una distribución exponencial con una tasa lambda configurable, donde lambda representa el número promedio de lotes que llegan por unidad de tiempo. En este proyecto, el valor por defecto de lambda es 0.022107 lotes por hora, lo cual significa que en promedio llega aproximadamente un lote cada 45 horas. La distribución exponencial es apropiada para modelar tiempos entre llegadas porque refleja procesos donde los eventos ocurren de manera independiente y aleatoria, y es matemáticamente tratable permitiendo calcular fácilmente probabilidades y tiempos esperados. Los tamaños de los lotes siguen una secuencia fija cíclica de 200, 150 y 50 prendas que se repite indefinidamente, lo cual proporciona un promedio de 133.33 prendas por lote. Esta secuencia fija refleja la realidad observada en los procesos de producción donde los tamaños de lote tienden a seguir patrones específicos en lugar de ser completamente aleatorios. El primer lote llega inmediatamente al inicio de la simulación en tiempo t=0 para facilitar la observación del comportamiento del sistema desde el primer momento.

Los tiempos de servicio en cada estación de trabajo también siguen una distribución exponencial, pero con tasas diferentes para cada servidor que reflejan las capacidades reales de procesamiento de cada máquina. La estación S1, correspondiente a la Cama Plana, tiene una tasa de servicio mu1 de 41.5420 prendas por hora. La estación S2, la Fileteadora, tiene una tasa mu2 de 56.8200 prendas por hora. La estación S3, el Collarete, también tiene una tasa mu3 de 56.8200 prendas por hora, igual que la Fileteadora. Finalmente, la estación S4, la Plancha, tiene la tasa más alta con mu4 de 72.0000 prendas por hora, lo cual refleja que esta estación final es capaz de procesar prendas más rápidamente que las anteriores. La distribución exponencial para tiempos de servicio es apropiada cuando los tiempos de procesamiento tienen una alta variabilidad y no pueden ser predichos con certeza, lo cual es común en procesos de manufactura donde factores como la complejidad de cada prenda pueden afectar significativamente el tiempo requerido.

El flujo de las prendas a través del sistema es estrictamente secuencial, donde cada prenda debe pasar por todas las estaciones en orden, comenzando en S1, luego moviéndose a S2, después a S3, y finalmente a S4 antes de salir del sistema. Cada estación tiene su propia cola de espera donde las prendas esperan a ser procesadas si el servidor está ocupado, y las colas funcionan con disciplina First-In-First-Out donde la primera prenda que llega es la primera en ser procesada. Esta estructura en serie crea dependencias entre las estaciones, donde un cuello de botella en una estación puede afectar a todas las estaciones posteriores, y las mejoras en una estación pueden no traducirse necesariamente en mejoras del sistema completo si otra estación se convierte en el nuevo cuello de botella.

El generador de números aleatorios implementado utiliza el algoritmo XORShift32, que es un algoritmo de generación de números pseudoaleatorios extremadamente rápido y eficiente. Este algoritmo opera mediante operaciones de desplazamiento de bits y operaciones XOR que son computacionalmente muy baratas, proporcionando números pseudoaleatorios uniformemente distribuidos en el intervalo [0, 1). Una característica crucial de este generador es que es completamente determinístico, lo cual significa que con la misma semilla inicial siempre producirá exactamente la misma secuencia de números aleatorios. Esta propiedad es esencial para la reproducibilidad de las simulaciones, permitiendo que diferentes ejecuciones con los mismos parámetros y la misma semilla produzcan resultados idénticos, lo cual es fundamental para validar el comportamiento del sistema y comparar resultados bajo diferentes configuraciones. El algoritmo tiene un período extremadamente largo de 2³² - 1, lo cual significa que la secuencia de números aleatorios no se repetirá durante un número astronómico de iteraciones, asegurando así que no habrá patrones detectables en las simulaciones de duración práctica.

Para generar tiempos que sigan distribuciones probabilísticas específicas, el sistema utiliza el método de transformación inversa, que es una técnica estándar en simulación estocástica. Para generar tiempos que sigan una distribución exponencial con una tasa dada, el sistema genera un número aleatorio uniforme U en el intervalo [0, 1), y luego calcula el tiempo mediante la fórmula -ln(U) / rate, donde ln es el logaritmo natural y rate es la tasa de la distribución. Esta transformación matemática garantiza que los tiempos generados seguirán exactamente la distribución exponencial deseada, con la propiedad de que tiempos más cortos son más probables que tiempos largos, lo cual es característico de procesos exponenciales.

## 6. Métricas y Análisis de Rendimiento

El simulador calcula una amplia gama de métricas que permiten analizar el rendimiento del sistema desde múltiples perspectivas. A nivel de cada servidor individual, el sistema calcula el largo actual de la cola que representa el número de prendas esperando para ser procesadas en ese momento específico. Esta métrica es fundamental para identificar cuellos de botella y entender cómo se distribuye la carga de trabajo entre las diferentes estaciones. Adicionalmente, el sistema calcula el tiempo promedio que las prendas pasan esperando en la cola de cada servidor, lo cual se obtiene dividiendo la suma acumulada de todos los tiempos de espera por el número de trabajos que han completado el servicio en ese servidor. Esta métrica es crucial para entender la experiencia de las prendas en el sistema y para identificar estaciones donde las colas son particularmente largas o problemáticas.

El tiempo promedio de servicio en cada servidor se calcula de manera similar, acumulando todos los tiempos de servicio reales y dividiendo por el número de trabajos completados. Esta métrica refleja la eficiencia real de cada estación de trabajo y puede revelar si hay problemas de rendimiento específicos en alguna máquina. A nivel del sistema completo, el simulador calcula el largo total de todas las colas sumando las colas de todos los servidores, lo cual proporciona una visión general de la carga total del sistema en cualquier momento. El tiempo promedio en el sistema se calcula desde el momento en que una prenda entra al sistema en S1 hasta el momento en que sale completamente procesada de S4, acumulando estos tiempos totales y dividiendo por el número de prendas que han completado todo el proceso. Esta métrica es particularmente valiosa porque refleja la experiencia completa de una prenda desde su llegada hasta su salida, y es directamente relevante para decisiones de planificación y optimización.

El throughput, o tasa de salida, representa el número de prendas que salen del sistema por unidad de tiempo, calculado mediante un método de suavizado que promedia las salidas recientes para proporcionar una estimación estable y no afectada por la variabilidad aleatoria de eventos individuales. Esta métrica es fundamental para entender la productividad del sistema y para comparar el rendimiento bajo diferentes configuraciones de parámetros.

Todas estas métricas se calculan de manera acumulativa durante la ejecución de la simulación, registrando información detallada cada vez que se procesa un evento de salida. Cuando una prenda completa su servicio en un servidor y se mueve al siguiente o sale del sistema, el simulador calcula el tiempo que esa prenda pasó esperando en la cola restando el tiempo de inicio de servicio del tiempo en que entró a la cola, registra el tiempo de servicio que fue determinado cuando se inició el procesamiento, y calcula el tiempo total en el sistema desde que la prenda entró inicialmente hasta su salida final. Todos estos valores se acumulan en contadores que mantienen sumas totales y conteos de trabajos completados, y cuando se necesita mostrar una métrica promedio, simplemente se divide la suma acumulada por el número de trabajos completados. Este enfoque acumulativo es computacionalmente eficiente y permite calcular métricas precisas sin necesidad de almacenar información detallada de cada prenda individual, lo cual sería prohibitivo en términos de memoria para simulaciones largas.

## 7. Funcionalidades y Características del Sistema

El simulador proporciona una pantalla de configuración inicial desarrollada en el componente ConfigScreen.tsx que permite al usuario configurar todos los parámetros relevantes antes de iniciar la simulación. Esta pantalla incluye explicaciones detalladas de cada parámetro con ejemplos prácticos que ayudan al usuario a entender el significado e impacto de cada valor. La configuración incluye controles deslizantes para ajustar lambda que representa la tasa de llegada de lotes, el factor B que representa el tamaño promedio del lote aunque actualmente los tamaños son fijos, las tasas de servicio mu para cada uno de los cuatro servidores, el factor de velocidad que controla qué tan rápido avanza el tiempo simulado relativo al tiempo real, y un campo numérico para la semilla del generador de números aleatorios. El diseño de esta pantalla es responsivo y se adapta a diferentes tamaños de pantalla, validando los rangos de entrada para asegurar que los valores sean razonables y estén dentro de límites operacionales.

La visualización tridimensional proporciona una representación en tiempo real de la línea de producción con modelos tridimensionales realistas de máquinas de coser y trabajadores que se renderizan utilizando las tecnologías Three.js y React Three Fiber. Las barras de cola crecen dinámicamente según la cantidad de prendas esperando en cada estación, proporcionando una representación visual inmediata del estado de las colas. La iluminación está configurada con luces ambientales y direccionales que crean sombras realistas y mejoran la percepción de profundidad y forma de los objetos tridimensionales. La cámara es completamente interactiva mediante controles de órbita que permiten al usuario rotar la vista alrededor de la escena, hacer zoom para acercarse o alejarse, y desplazar la vista para examinar diferentes áreas del sistema desde diferentes ángulos.

El sistema incluye múltiples paneles de información que muestran diferentes aspectos del estado del sistema. El panel de métricas detalladas ubicado en la esquina superior izquierda muestra métricas específicas para cada servidor incluyendo el largo actual de cola, el tiempo promedio en cola, y el tiempo promedio de servicio, además de métricas del sistema completo como el largo total de todas las colas y el tiempo promedio total en el sistema. Todos los tiempos se presentan en un formato legible que muestra horas, minutos y segundos, facilitando la interpretación de los valores. El panel de próxima llegada ubicado en la esquina superior derecha muestra el tiempo simulado en que está programada la siguiente llegada de un lote y calcula dinámicamente el tiempo restante hasta esa llegada, lo cual ayuda a anticipar cuándo llegará la siguiente carga de trabajo al sistema.

Un resumen compacto ubicado en la esquina inferior derecha proporciona una visión general rápida del estado del sistema mostrando el tiempo simulado actual, el throughput estimado, el estado de cada cola mostrando cuántas prendas esperan en cada una, y el estado de cada servidor indicando si está ocupado procesando una prenda o está libre y disponible. La pantalla principal en el centro muestra el día y la hora simulada en un formato legible con el nombre del día de la semana, la hora en formato de 12 horas con indicador AM o PM, y el estado laboral actual que puede ser "TRABAJANDO" cuando el sistema está en horario laboral activo, "DESCANSO DE ALMUERZO" durante los períodos de descanso programados, o "FUERA DE HORARIO LABORAL" durante los períodos fuera de los turnos definidos o durante los domingos.

Durante la ejecución de la simulación, el sistema proporciona controles en tiempo real mediante el panel de Leva que permite ajustar parámetros sin necesidad de reiniciar la simulación. Estos controles permiten modificar lambda para cambiar la tasa de llegada de lotes, ajustar las tasas de servicio mu de cada servidor individual, cambiar el factor de velocidad para acelerar o desacelerar la simulación, y modificar la semilla del generador de números aleatorios para explorar diferentes escenarios estocásticos. Un botón de reset permite reiniciar completamente la simulación con los nuevos parámetros, lo cual es útil para comparar resultados bajo diferentes configuraciones.

## 8. Flujo de Ejecución y Procesamiento de Eventos

El flujo de ejecución del simulador comienza cuando el usuario abre la aplicación, momento en el cual el componente App.tsx renderiza la pantalla de configuración ConfigScreen que permite al usuario establecer todos los parámetros iniciales. El usuario puede ajustar los valores mediante controles deslizantes y campos numéricos, y estos valores se almacenan en un estado local dentro del componente ConfigScreen sin afectar inmediatamente el motor de simulación. Cuando el usuario está satisfecho con la configuración y presiona el botón "Iniciar", el componente ConfigScreen llama a la función handleStart que aplica todos los parámetros al store de Zustand mediante setParams, actualiza el estado isSimulating a true en App.tsx, y la aplicación transiciona de la pantalla de configuración a la escena de simulación.

Una vez iniciada la simulación, App.tsx ejecuta un loop continuo basado en requestAnimationFrame que se sincroniza con la tasa de refresco del navegador, típicamente 60 cuadros por segundo. En cada iteración del loop, el componente calcula el tiempo transcurrido desde el último frame en segundos reales, y llama a la función tick del store de Zustand pasándole este delta de tiempo. La función tick multiplica este tiempo real por el factor de velocidad configurado para determinar cuánto tiempo simulado debe avanzarse, y luego llama al método step del motor de simulación pasándole este tiempo simulado. El método step del motor avanza el tiempo simulado del sistema y procesa todos los eventos que están programados para ocurrir durante ese intervalo de tiempo, ejecutándolos en orden cronológico estricto. Después de procesar todos los eventos del intervalo, el motor genera un nuevo snapshot del sistema que contiene todas las métricas actualizadas y estados actuales, y este snapshot se actualiza en el store de Zustand. Esta actualización automáticamente dispara el re-renderizado de todos los componentes React que están suscritos al estado, incluyendo Scene.tsx y todos sus componentes hijos, resultando en una actualización visual en tiempo real de toda la escena tridimensional.

El procesamiento de eventos es el núcleo de la simulación de eventos discretos, y cada tipo de evento se maneja de manera específica. Cuando se procesa un evento de tipo ARRIVAL, el motor crea un objeto Batch que representa el lote de prendas que ha llegado, determina el tamaño del lote utilizando la secuencia fija cíclica, y crea un objeto Job individual para cada prenda dentro del lote. Cada job se encola en la cola del primer servidor S1, registrando el tiempo actual como el tiempo de entrada al sistema y el tiempo de inicio de espera en cola. Después de encolar todos los jobs, el motor intenta iniciar el servicio en S1 si el servidor está libre y hay trabajos esperando, lo cual implica remover el primer trabajo de la cola, establecer el tiempo de inicio de servicio, generar un tiempo de servicio aleatorio según la distribución exponencial con la tasa mu del servidor, y programar un evento DEPARTURE para el momento en que el servicio se completará. Finalmente, el motor programa la siguiente llegada de lote calculando un tiempo entre llegadas aleatorio según la distribución exponencial con tasa lambda, y agregando un nuevo evento ARRIVAL al calendario de eventos.

Cuando se procesa un evento de tipo DEPARTURE, el motor identifica qué servidor está completando el servicio, finaliza el servicio en ese servidor liberando el recurso, y calcula las métricas acumulativas. El tiempo que la prenda pasó en la cola se calcula como la diferencia entre el tiempo de inicio de servicio y el tiempo de entrada a la cola, y este valor se suma al contador de tiempo total en cola para ese servidor. El tiempo de servicio que fue determinado cuando se inició el procesamiento se suma al contador de tiempo total de servicio. Si el servidor no es el último en la cadena, el trabajo se mueve a la cola del siguiente servidor, registrando el nuevo tiempo de entrada a esa cola. Si el servidor es S4, el último en la cadena, el trabajo sale completamente del sistema, y el tiempo total en el sistema se calcula como la diferencia entre el tiempo actual y el tiempo de entrada original al sistema, acumulándose este valor para las métricas del sistema completo. Después de mover o eliminar el trabajo, el motor intenta iniciar servicio en el servidor actual si hay trabajos esperando en su cola, y también intenta iniciar servicio en el servidor anterior si hay trabajos esperando allí, lo cual es importante porque cuando un trabajo sale de un servidor, puede permitir que el servidor anterior procese el siguiente trabajo en su cola.

## 9. Consideraciones Técnicas de Implementación

El rendimiento del simulador está optimizado mediante varias técnicas y decisiones arquitectónicas. El uso de requestAnimationFrame asegura que el loop de simulación se sincronice con la tasa de refresco del navegador, típicamente 60 cuadros por segundo, lo cual proporciona una experiencia visual fluida mientras evita renderizados innecesarios que desperdiciarían recursos computacionales. La clonación profunda de modelos tridimensionales para cada trabajador asegura que cada instancia sea completamente independiente, previniendo que Three.js optimice o una las instancias de manera que podría causar problemas visuales o de comportamiento. Esta técnica, aunque consume más memoria, es esencial para el correcto funcionamiento del sistema cuando se renderizan múltiples instancias del mismo modelo.

React Three Fiber optimiza automáticamente el renderizado tridimensional mediante técnicas como frustum culling que evita renderizar objetos fuera del campo de visión de la cámara, y mediante la gestión eficiente del ciclo de vida de objetos 3D que permite reutilizar recursos cuando es posible. Zustand proporciona actualizaciones eficientes del estado mediante un sistema de suscripciones selectivas donde los componentes solo se re-renderizan cuando cambian las partes específicas del estado a las que están suscritos, minimizando así el trabajo computacional necesario para mantener la interfaz actualizada.

La reproducibilidad de las simulaciones está garantizada mediante varios mecanismos. El uso de una semilla configurable para el generador de números aleatorios permite que cualquier simulación pueda ser reproducida exactamente ejecutando el sistema con los mismos parámetros y la misma semilla, lo cual es esencial para validar resultados, comparar diferentes configuraciones, y depurar problemas. El algoritmo XORShift32 utilizado es completamente determinístico, garantizando que con la misma semilla siempre se generará exactamente la misma secuencia de números aleatorios, y por lo tanto los mismos tiempos de llegada y servicio. Los tamaños de lote son una secuencia fija cíclica en lugar de ser aleatorios, lo cual asegura que el patrón de llegadas sea reproducible y predecible.

La escalabilidad del sistema está facilitada por la arquitectura modular donde cada componente tiene responsabilidades bien definidas y está relativamente desacoplado de los demás. Esta estructura permite agregar fácilmente más servidores al sistema modificando principalmente la configuración y agregando las instancias correspondientes en la escena, sin necesidad de reescribir grandes porciones del código. El uso de TypeScript con tipado fuerte previene errores cuando se modifica el código, ya que el compilador detecta incompatibilidades de tipos antes de que el código sea ejecutado. La separación clara entre la capa de presentación, la capa de estado, y la capa de lógica de negocio asegura que los cambios en una capa no afecten necesariamente a las otras, facilitando el mantenimiento y la extensión del sistema.

## 10. Parámetros y Configuración del Sistema

El simulador utiliza parámetros por defecto que reflejan valores reales observados en operaciones de producción textil. La tasa de llegada lambda está configurada en 0.022107 lotes por hora, lo cual significa que en promedio llega aproximadamente un lote cada 45 horas de tiempo simulado. El parámetro B representa el tamaño promedio del lote y está configurado en 133.3333 prendas, aunque este valor es principalmente informativo ya que los tamaños reales de los lotes siguen una secuencia fija. Las tasas de servicio mu para cada servidor están configuradas en valores que reflejan las capacidades reales de cada máquina: la estación S1 correspondiente a la Cama Plana tiene una tasa de 41.5420 prendas por hora, la estación S2 correspondiente a la Fileteadora tiene una tasa de 56.8200 prendas por hora, la estación S3 correspondiente al Collarete también tiene una tasa de 56.8200 prendas por hora, y la estación S4 correspondiente a la Plancha tiene la tasa más alta con 72.0000 prendas por hora. El factor de velocidad está configurado en 500, lo cual significa que cada segundo de tiempo real equivale a 500 horas de tiempo simulado, permitiendo observar el comportamiento del sistema a largo plazo en un período razonable de tiempo. La semilla por defecto del generador de números aleatorios está configurada en 1234, aunque el usuario puede cambiarla para explorar diferentes escenarios estocásticos.

Los tamaños de lote siguen una secuencia fija cíclica de 200, 150 y 50 prendas que se repite indefinidamente. Esta secuencia proporciona un promedio de exactamente 133.33 prendas por lote cuando se calcula sobre múltiples ciclos, y refleja la variabilidad real observada en los procesos de producción donde los lotes no tienen tamaños uniformes sino que varían según factores como la capacidad de los proveedores, los requisitos de producción, y las limitaciones logísticas. El primer lote que llega al sistema tiene un tamaño de 200 prendas, el segundo tiene 150 prendas, el tercero tiene 50 prendas, el cuarto vuelve a tener 200 prendas, y así sucesivamente en un ciclo continuo.

## 11. Conclusión

Este simulador representa una integración exitosa de tecnologías modernas de desarrollo web con técnicas avanzadas de simulación computacional, creando una herramienta interactiva y visualmente atractiva para el análisis de sistemas de producción. La combinación de React y TypeScript proporciona una base sólida y mantenible para la interfaz de usuario, mientras que Three.js y React Three Fiber permiten una visualización tridimensional inmersiva que facilita la comprensión intuitiva del comportamiento del sistema. La arquitectura modular del proyecto, con clara separación entre presentación, estado y lógica de negocio, facilita el mantenimiento y la extensión del sistema, permitiendo que nuevas funcionalidades puedan ser agregadas sin afectar componentes existentes.

El uso de TypeScript como lenguaje principal asegura que el código sea robusto y libre de errores comunes mediante la detección temprana de problemas de tipos, mientras que las tecnologías de visualización 3D proporcionan una experiencia de usuario rica que va más allá de simples gráficos o tablas de datos. El motor de simulación de eventos discretos implementado es eficiente y preciso, calculando métricas relevantes que permiten análisis cuantitativos del rendimiento del sistema bajo diferentes condiciones operacionales. La capacidad de reproducir exactamente las mismas simulaciones mediante el uso de semillas configurables es esencial para validar resultados y comparar diferentes escenarios, mientras que la flexibilidad para ajustar parámetros en tiempo real permite una exploración interactiva del espacio de parámetros del sistema.

El proyecto demuestra que es posible crear herramientas de simulación sofisticadas utilizando tecnologías web estándar, haciendo que el análisis de sistemas de producción sea accesible a través de cualquier navegador web moderno sin necesidad de software especializado o instalaciones complejas. La visualización tridimensional proporciona una comprensión intuitiva del comportamiento del sistema que complementa los análisis cuantitativos proporcionados por las métricas numéricas, creando así una herramienta educativa valiosa que puede ser utilizada tanto para fines académicos como para análisis prácticos en entornos industriales reales.

**Versión del Documento**: 1.0  
**Fecha**: 2024  
**Autor**: Sistema de Simulación de Producción Textil
